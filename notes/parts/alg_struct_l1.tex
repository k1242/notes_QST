Рассмотрим модель WordRAM. Есть RAM (Random Access Memory) -- запоминающее устройство с произвольным доступом. Есть процессор, в котором сколько-то регистров, не так принципиально с точки зрения асимптотик сколько. В каждой ячейка RAM хранится word длины $w \sim 64$ -- соответсвующего битовой длине слова. Если размер памяти $M$, и мы хотим уметь обращаться к её кусочкам. Адреса имеют ту же самую битность, что и значения. Таким образом $M \leq 2^w$. 

Естетсвенно рассмотреть инструкции \texttt{load} (из $r[j] \leftarrow \text{RAM}\,[r[i]]$) и \texttt{store} ($\text{RAM}[r[i]] \leftarrow r[j]$), которые и задают машину. А так есть вся арифметика, есть логические операции и всякие прочие битовые операции. Но этого недостаточно. Хочется организовать циклы: \texttt{jump}, \texttt{label}, чтобы зацикливать операции. Ну и само собой операции сравнения. Из этого получили набор элементарных операций. Каждое из них стоит константу. Вообще всё что в AC$^0$ будем считать элементарной операцией. 


Что бы называем временем алгоритма? Рассмотрим time(input) но скорее time($n$), где $n$ -- размер входа, что бы это ни значило. А дальше из всех времен мы рассматриваем худший случай, средний случай.  

Для случайного алгоритма удобно воспринимать его как детерминированный с доступоп к мешку случайных чисел. Тогда время работы можно задать как
\begin{equation*}
	\text{rand time}(n) = \max_{\text{input}} \text{avg}\, \text{time} (\text{input},\, \text{rand}).
\end{equation*}

% x86-64

% поботать assembler 




